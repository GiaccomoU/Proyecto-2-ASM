section .bss

	bufferExpresion:	resb buffExpresionLen
	buffExpresionLen:	equ 1024

	bufferExpTemp:		resb buffExpTempLen
	buffExpTempLen:		equ 1024

	buffVar1:			resw 10
	buffVar1Len:		equ $ - buffVar1

	buffVar2:			resw 10
	buffVar2Len:		equ $ - buffVar2

	buffVar3:			resw 10
	buffVar3Len:		equ $ - buffVar3

	buffVar4:			resw 10
	buffVar4Len:		equ $ - buffVar4

	buffVar5:			resw 10
	buffVar5Len:		equ $ - buffVar5

	buffVar6:			resw 10
	buffVar6Len:		equ $ - buffVar6

	buffVar7:			resw 10
	buffVar7Len:		equ $ - buffVar7

	buffVar8:			resw 10
	buffVar8Len:		equ $ - buffVar8

	buffVar9:			resw 10
	buffVar9Len:		equ $ - buffVar9

	buffVar10:			resw 10
	buffVar10Len:		equ $ - buffVar10

	buffVar11:			resw 10
	buffVar11Len:		equ $ - buffVar11

	buffVar12:			resw 10
	buffVar12Len:		equ $ - buffVar12

	buffVar13:			resw 10
	buffVar13Len:		equ $ - buffVar13

	buffVar14:			resw 10
	buffVar14Len:		equ $ - buffVar14

	buffVar15:			resw 10
	buffVar15Len:		equ $ - buffVar15

	buffVar16:			resw 10
	buffVar16Len:		equ $ - buffVar16

	buffVar17:			resw 10
	buffVar17Len:		equ $ - buffVar17

	buffVar18:			resw 10
	buffVar18Len:		equ $ - buffVar18

	buffVar19:			resw 10
	buffVar19Len:		equ $ - buffVar19

	buffVar20:			resw 10
	buffVar20Len:		equ $ - buffVar20

section .data

	instruccion1: 		db 10,"******************************* Proyecto #2 *******************************",10,0
	lenInstruccion1: 	equ $ - instruccion1

	instruccion2: 		db 10,"      Escriba la expresión matématica con un máximo de 20 variables:",10,0
	lenInstruccion2:	equ $ - instruccion2

	ErrorParentesis: 	db "             Expresión Algebraica inválida: Paréntesis incorrectos",10,0
	lenErrorParentesis:	equ $ - ErrorParentesis

	ErrorGen:			db "                         Expresión Algebraica inválida",10,0
	lenErrorGen:		equ $ - ErrorGen

	ErrorVacio:			db "             		  Expresión Algebraica inválida: Vacía",10,0
	lenErrorVacio:		equ $ - ErrorVacio

	ErrorMaxChar:		db "Expresión Algebraica inválida: Las variables deben tener un valor máximo de 9999",10,0
	lenErrorMaxChar:	equ $ - ErrorMaxChar

	ErrorVar:			db "                                Variable inválida",10,0
	lenErrorVar:		equ $ - ErrorVar

	ErrorConst:			db "		              ERROR: Faltan variables por definir",10,0
	lenErrorConst		equ $ - ErrorConst

section .text

global _start

_start:

main:

	call comenzar

ExpAlg:

	call leerExpresion
	; No usar r15, va a guardar el largo de la expresión

	;==================================== RESTRICCIONES ====================================================

	call verificarCaracteres			; verifica que la expresión sólo tenga caracteres válidos
	call verificarParentesis  			; Verifica que los paréntesis estén balanceados
	call verificarSimbolos				; Verifica que no hayan signos al principio al final, ni dos juntos
	call quitarEspacios					; Elimina los espacios de la EA
	call agregarMul				        ; agrega los *'s en donde hay multiplicaciones implícitas
	; Después de esto r15 deja de contar al enter en la expresión algebraica
	
	jmp  verificarComa					; Verifica si EA termina en coma y que ésta esté al final


Vars:

	call leerVariables 					
	; Aquí se leen la variables, se guarda en r14 el número de éstas
	call reemplazarVariables			; reemplaza variables por sus valores y verifica que las usadas estén especificadas
	; Después de esto r14 ya está libre para otros usos :)
Operar:
	
	call agregarParentesis				; agrega parentesis para preparar a la expresión antes de ser operada
	
	jmp  exit

imprimir:				; rsi: Mensaje a imprimir, rdx: Longitud del mensaje

	mov rax,1			; file descriptor (sys_write)
	mov rdi,1			; system call number (std out)
	syscall
	ret

leerExpresion:

	mov rax, 0						; sys_read (code 0)
	mov rdi, 0						; file descriptor (code 0 stdin)
	mov rsi, bufferExpresion		; address to the buffer to read into
	mov rdx, buffExpresionLen		; number of bytes to read
	syscall
	mov r15, rax
	ret

verificarCaracteres:
	
	xor r9, r9
	xor rsi, rsi
	xor r10, r10
	mov r9, rax
	dec r9

	.comparar:

		cmp byte[bufferExpresion + rsi], '*'
		je .siguiente
		cmp byte[bufferExpresion + rsi], '+'
		je .siguiente
		cmp byte[bufferExpresion + rsi], '-'
		je .siguiente
		cmp byte[bufferExpresion + rsi], '/'
		je .siguiente
		cmp byte[bufferExpresion + rsi], '('
		je .siguiente
		cmp byte[bufferExpresion + rsi], ')'
		je .siguiente
		cmp byte[bufferExpresion + rsi], ' '
		je .siguiente
		cmp byte[bufferExpresion + rsi], ','
		je .siguiente
		cmp byte[bufferExpresion + rsi], 0Ah ; Enter
		je .siguiente
		cmp byte[bufferExpresion + rsi], 30h
		jb .error
		cmp byte[bufferExpresion + rsi], 39h
		ja .buscarLetras
		jmp .siguiente

	.buscarLetras
		cmp byte[bufferExpresion + rsi], 61h
		jb .error
		cmp byte[bufferExpresion + rsi], 7Ah
		jbe .siguiente

	.error:

		mov rsi, ErrorGen
		mov rdx, lenErrorGen
		call imprimir
		jmp exit

	.siguiente:

		inc rsi
		cmp rsi, r9
		jne .comparar
		ret

verificarComa:

	xor r9, r9				
	mov r9, r15				; r15 tiene el tamaño de BufferExpresion
	dec r9
	xor rcx, rcx
	mov rsi, bufferExpresion ; Le pasa la dirección de bufferExpresion a rsi

	.buscarComa:

		cmp byte[rsi + rcx], ','		;Compara el caracter actual con una coma
		je .CompararFinal
		cmp rcx, r9
		je .verificarConstantes 					; Ĺlegó al final y no había comas
		inc rcx
		jmp .buscarComa

	.CompararFinal:

		dec r9
		cmp r9, rcx
		jne .Error
		cmp r9, 0
		je .Error
		jmp Vars						; Sí hay una coma y está al final

	.Error:

		mov rsi, ErrorGen
		mov rdx, lenErrorGen
		call imprimir
		jmp exit

	.verificarConstantes:

		xor rcx, rcx
		xor rax, rax
		mov rax, r15			; Le pasa el tamaño de el buffer a rax
		;sub rax, 2				; 

	.ciclo:

		cmp byte[rsi + rcx], 61h  ; ¿Es menor a 'a'?
		jb .fin					  ; Sí es menor a 'a', no es una letra
		cmp byte[rsi + rcx], 7Ah  ; ¿Es menor a 'z'?
		jbe .error       		  ; Es una letra

	.fin:
		inc rcx
		cmp rcx, rax
		je  .salir
		jmp .ciclo

	.error:

		mov rsi, ErrorConst
		mov rdx, lenErrorConst
		call imprimir
		jmp exit

	.salir:
		jmp Operar

verificarParentesis:

	mov  rax, r15
	dec  rax
	mov  r9,  0 ; Contador de validación de paréntesis
	mov  rcx, 0
	mov  rsi, 0

	.inicio:

		cmp r9, 0
		jl  .parentesisDesbalanceados
		cmp byte[bufferExpresion + rsi], 28h ; Si el caracter es un paréntesis abierto '('
		je  .incrementarR9
		cmp byte[bufferExpresion + rsi], 29h ; Si el caracter es un paréntesis cerrado ')'
		je  .decrementarR9
		jmp .next

	.incrementarR9:

		inc r9
		jmp .next

	.decrementarR9:

		dec r9
		jmp .next

	.parentesisDesbalanceados:
		
		mov  rsi, ErrorParentesis
		mov  rdx, lenErrorParentesis
		call imprimir
		jmp  exit

	.next:

		inc rsi
		inc rcx
		cmp rcx, rax 	; Compara el max de caracteres de la expresión dada, con el número de caracteres que ha leído
		jne .inicio
		cmp r9, 0
		jne .parentesisDesbalanceados
		ret

verificarSimbolos:

	xor rsi, rsi
	xor rcx, rcx		; contador de veces repetidas
	xor rbx, rbx		; contador de pares de caracteres juntos

	.verSignoInicio:

		cmp byte[bufferExpresion + rsi], '+'
		je .error
		cmp byte[bufferExpresion + rsi], '*'
		je .error
		cmp byte[bufferExpresion + rsi], '/'
		je .error

	.verSignoFinal:

		mov rsi, r15
		sub rsi, 1
		cmp byte[bufferExpresion + rsi], '+'
		je .error
		cmp byte[bufferExpresion + rsi], '-'
		je .error
		cmp byte[bufferExpresion + rsi], '*'
		je .error
		cmp byte[bufferExpresion + rsi], '/'
		je .error

		xor rsi, rsi

	.buscarDobles:

		inc rbx
		cmp rbx, 3
		je .resetBnC
		inc rsi
		cmp rsi, r15
		je .terminar

		cmp byte[bufferExpresion + rsi], '+'
		je .sumarUno
		cmp byte[bufferExpresion + rsi], '-'
		je .sumarUno
		cmp byte[bufferExpresion + rsi], '*'
		je .sumarUno
		cmp byte[bufferExpresion + rsi], '/'
		je .sumarUno

		jmp .buscarDobles


	.resetBnC:
		xor rbx, rbx
		xor rcx, rcx
		jmp .buscarDobles

	.sumarUno:

		inc rcx
		cmp rcx, 2
		je .error
		jmp .buscarDobles

	.error:

		mov rsi, ErrorGen
		mov rdx, lenErrorGen
		call imprimir
		jmp exit

	.terminar:

		ret

leerVariables: 
	xor r14, r14						; va a guardar el número de variables
	xor r12, r12
	mov r12, 2

	.Var1:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar1
		mov rdx, buffVar1Len
		syscall
		mov rcx, 0
		mov rsi, buffVar1
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra=Num"
		inc r14


	.Var2:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar2
		mov rdx, buffVar2Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar 
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var3:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar3
		mov rdx, buffVar3Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var4:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar4
		mov rdx, buffVar4Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var5:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar5
		mov rdx, buffVar5Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var6:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar6
		mov rdx, buffVar6Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var7:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar7
		mov rdx, buffVar7Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var8:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar8
		mov rdx, buffVar8Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var9:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar9
		mov rdx, buffVar9Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var10:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar10
		mov rdx, buffVar10Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var11:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar11
		mov rdx, buffVar11Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var12:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar12
		mov rdx, buffVar12Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar 
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var13:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar13
		mov rdx, buffVar13Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var14:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar14
		mov rdx, buffVar14Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var15:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar15
		mov rdx, buffVar15Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var16:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar16
		mov rdx, buffVar16Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var17:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar17
		mov rdx, buffVar17Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var18:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar18
		mov rdx, buffVar18Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var19:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar19
		mov rdx, buffVar19Len
		syscall
		mov rcx, 0
		call .buscarComa
		cmp rcx, -1
		je .terminar
		call verificarFormatoVariables 		; Verifica que las variables sean de formato: "Letra = Num"
		inc r14

	.Var20:
		mov rax, 0						; sys_read (code 0)
		mov rdi, 0						; file descriptor (code 0 stdin)
		mov rsi, buffVar20
		mov rdx, buffVar20Len
		syscall
		mov rcx, 0
		inc r14
		jmp .terminar

	.buscarComa:
		cmp byte[rsi+rcx], 0; si llegue al final de lo que escribio y no encontre una coma
			je .salir
		cmp byte[rsi+rcx],','; si es una coma, se cambia de linea y termina el ciclo
			je .seguir
		inc rcx
		jmp .buscarComa; continuo	

	.seguir:
		ret

	.salir:
		mov rcx, -1			; Bandera: No encontró coma al final
		ret

	.terminar:
		mov r12, 1
		call verificarFormatoVariables 		; En este caso, r12 indica que ya no tiene coma
		ret

verificarFormatoVariables: ; Argumentos: rsi, buffer; rax, largo; r12 es 1 si 

	sub rax, r12			; Para que sólo tome en cuenta el tamaño hasta antes de la coma
	xor r10, r10
	xor r11, r11
	mov r11, 7				; El límite de dígitos que una variable podrá tener: "a = 9999"
	
	.compararLetra:
		cmp byte[rsi + r10], 61h
		jb .error
		cmp byte[rsi + r10], 7Ah
		ja .error
		inc r10
		jmp .buscarSimboloIgual

	.buscarSimboloIgual:

		cmp r10, rax
		je .error

	.buscar:

		cmp byte[rsi + r10], '='
		jne .error
		inc r10
		jmp .buscarNumero

	.buscarNumero:

		cmp r10, rax
		je .error

	.posibleNegativo:

		cmp byte[rsi + r10], '-'
		jne .buscarNum
		inc r10
		cmp r10, rax
		je .error

	.buscarNum:

		cmp byte[rsi + r10], 30h
		jb .error
		cmp byte[rsi + r10], 39h
		ja .error

	.nextCont:

		dec r11
		cmp r11, 0
		je .errorMaxChar  ; llegó al máximo de caracteres

	.next:

		inc r10
		cmp r10, rax
		je .compararMax
		jmp .buscarNum

	.compararMax:

		cmp r11, 7
		jb .terminar
		jmp .error

	.error:

		mov rsi, ErrorVar
		mov rdx, lenErrorVar
		call imprimir
		jmp exit

	.errorVacio:

		mov rsi, ErrorVacio
		call imprimir
		jmp exit

	
	.errorMaxChar:

		mov rsi, ErrorMaxChar
		mov rdx, lenErrorMaxChar
		call imprimir
		jmp exit

	.terminar:
		ret

borrarEspacios:	; Argumentos, largo con coma y enter en rdx, largo sin coma ni enter en r9 y el buffer en rsi	

	xor r13, r13
	xor r10, r10  ; contador de espacios 
	xor rcx, rcx
	xor r11, r11  ; contador de espacios 
	xor r8, r8
	;mov rsi, bufferExpresion
	mov r13, r9
	sub r13, 2
	mov r8, r13
	inc r8

	.buscarEspacios:

		cmp byte[rsi + rcx], ' '
		je .contadorEspacios
		inc rcx
		cmp rcx, r13
		jne .buscarEspacios
		jmp .salir

	.contadorEspacios:

		mov r10, rcx

	.ciclo:
		inc r10
		cmp r10, r8		
		je .salir
		inc r11					; contador de las veces que hay que correr a la izquierda un caracter
		cmp byte[rsi + r10], ' '
		je .ciclo

	.mover:
		mov bl, byte[rsi + r10]
		mov byte[rsi + r10 -1], bl
		mov byte[rsi + r10], ' '
		dec r10
		dec r11
		cmp r11, 0
		je .buscarEspacios
		jmp .mover

	.salir:
		;mov rsi, bufferExpresion
		;mov rdx, buffExpresionLen
	;	call imprimir
		ret

copiarBuffer:

	xor r9, r9
	xor rax, rax
	xor r10, r10
	mov r10, r15
	dec r10

	.ciclo:

		mov al, [bufferExpTemp + r9]
		mov [bufferExpresion + r9], al
		inc r9
		cmp r9, r10	; condición de parada
		jne .ciclo
		call limpiarBuffer
		ret

limpiarBuffer:

	xor r9, r9

	.ciclo:

		mov byte[bufferExpTemp + r9], 0
		inc r9
		cmp byte[bufferExpTemp], 0
		jne .ciclo
		ret

reemplazarVariables:
	
	xor r8, r8	; contador de índices
	xor r9, r9	; va a guardar el largo del valor de cada variable
	xor r10, r10
	xor r12, r12
	xor rsi, rsi
	xor rax, rax
	xor rbx, rbx

	mov r12, r15
	dec r12

	.buscarVariable:

		cmp byte[bufferExpresion + r8], 61h
		jb .siguiente
		cmp byte[bufferExpresion + r8], 7Ah
		ja .siguiente
		mov bl, byte[bufferExpresion + r8] ; bl va a guardar la letra de la variable
		jmp .reemplazar

	.siguiente:

		mov al, byte[bufferExpresion + r8]
		mov byte[bufferExpTemp + r10], al 		; va copiando a bufferExpTemp todo lo que no sean variables
		inc r8
		inc r10
		cmp r8, r12			; condición de parada, si llegó al final y terminó de reemplazar
		je .salir
		jmp .buscarVariable

	.reemplazar:

		inc r8		; para que el valor de la variable empiece a caer sobre el sgte espacio
		cmp byte[buffVar1], bl
		je .var1
		cmp byte[buffVar2], bl
		je .var2
		cmp byte[buffVar3], bl
		je .var3
		cmp byte[buffVar4], bl
		je .var4
		cmp byte[buffVar5], bl
		je .var5
		cmp byte[buffVar6], bl
		je .var6
		cmp byte[buffVar7], bl
		je .var7
		cmp byte[buffVar8], bl
		je .var8
		cmp byte[buffVar9], bl
		je .var9
		cmp byte[buffVar10], bl
		je .var10
		cmp byte[buffVar11], bl
		je .var11
		cmp byte[buffVar12], bl
		je .var12
		cmp byte[buffVar13], bl
		je .var13
		cmp byte[buffVar14], bl
		je .var14
		cmp byte[buffVar15], bl
		je .var15
		cmp byte[buffVar16], bl
		je .var16
		cmp byte[buffVar17], bl
		je .var17
		cmp byte[buffVar18], bl
		je .var18
		cmp byte[buffVar19], bl
		je .var19
		cmp byte[buffVar20], bl
		je .var20
		jmp .error

	.var1:

		mov rsi, buffVar1
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var2:

		mov rsi, buffVar2
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var3:

		mov rsi, buffVar3
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var4:

		mov rsi, buffVar4
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var5:

		mov rsi, buffVar5
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var6:

		mov rsi, buffVar6
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var7:

		mov rsi, buffVar7
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var8:

		mov rsi, buffVar8
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var9:

		mov rsi, buffVar9
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var10:

		mov rsi, buffVar10
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var11:

		mov rsi, buffVar11
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var12:

		mov rsi, buffVar12
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var13:

		mov rsi, buffVar13
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var14:

		mov rsi, buffVar14
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var15:

		mov rsi, buffVar15
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var16:

		mov rsi, buffVar16
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var17:

		mov rsi, buffVar17
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var18:

		mov rsi, buffVar18
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var19:

		mov rsi, buffVar19
		xor r9, r9
		inc r9
		jmp .tomarValor

	.var20:

		mov rsi, buffVar20
		xor r9, r9
		inc r9
		jmp .tomarValor

	.tomarValor:

		inc r9
		cmp byte[rsi + r9], '-'
		je .copiar
		cmp byte[rsi + r9], 30h
		jb .buscarVariable
		cmp byte[rsi + r9], 39h
		ja .buscarVariable

	.copiar:

		mov al, [rsi + r9]
		mov [bufferExpTemp + r10], al
		inc r10
		jmp .tomarValor

	.error:

		mov rsi, ErrorConst
		mov rdx, lenErrorConst
		call imprimir
		jmp exit

	.salir:
		push rdi
		push rsi
		push rdx
		push rax

		;mov rsi, bufferExpTemp
		;mov rdx, buffExpTempLen

		;call imprimir

		pop rax
		pop rdx
		pop rsi
		pop rdi

		call copiarBuffer
		ret

agregarMul:

	xor r9, r9
	xor r10, r10
	xor r12, r12
	xor rax, rax

	mov r12, r15			; Movemos el tamaño de la expresión algebraica a r12
	dec r12					; Para ignorar el enter

	.buscarCaso:

		cmp byte[bufferExpresion + r9], ')'
		je .compararCasoParentesis
		cmp byte[bufferExpresion + r9], 30h
		jb .siguiente							; No es número ni letra
		cmp byte[bufferExpresion + r9], 39h
		jb .compararCasoNumero					; Es una número
		cmp byte[bufferExpresion + r9], 61h
		jb .siguiente							; No es letra
		cmp byte[bufferExpresion + r9], 7Ah
		jb .compararCasoLetra
		jmp .siguiente

	.siguiente:

		mov al, byte[bufferExpresion + r9]
		mov byte[bufferExpTemp + r10], al		; Copia al buffer temporal

	.copiar:
		inc r9
		inc r10 
		cmp r9, r12 
		je .salir
		jmp .buscarCaso

	.compararCasoParentesis:

		cmp byte[bufferExpresion + r9 + 1], ','
		je .terminar
		cmp byte[bufferExpresion + r9 + 1], '('
		je .ponerAsterisco
		cmp byte[bufferExpresion + r9 + 1], 30h
		jb .siguiente
		cmp byte[bufferExpresion + r9 + 1], 39h
		jb .ponerAsterisco
		cmp byte[bufferExpresion + r9 + 1], 61h
		jb .siguiente
		cmp byte[bufferExpresion + r9 + 1], 7Ah
		jb .ponerAsterisco
		jmp .siguiente

	.ponerAsterisco:

		mov al, byte[bufferExpresion + r9]
		mov byte[bufferExpTemp + r10], al
		inc r10			; para que llegue al espacio siguiente en donde pondrá el *
		mov byte[bufferExpTemp + r10], '*'
		inc r15
		jmp .copiar


	.compararCasoNumero:
		
		cmp byte[bufferExpresion + r9 + 1], ','
		je .terminar
		cmp byte[bufferExpresion + r9 + 1], '('
		je .ponerAsterisco
		cmp byte[bufferExpresion + r9 + 1], 61h
		jb .siguiente
		cmp byte[bufferExpresion + r9 + 1], 7Ah
		jb .ponerAsterisco
		jmp .siguiente

	.compararCasoLetra:

		cmp byte[bufferExpresion + r9 + 1], ','
		je .terminar
		cmp byte[bufferExpresion + r9 + 1], '('
		je .ponerAsterisco
		cmp byte[bufferExpresion + r9 + 1], 30h
		jb .siguiente
		cmp byte[bufferExpresion + r9 + 1], 39h
		jb .ponerAsterisco
		cmp byte[bufferExpresion + r9 + 1], 61h
		jb .siguiente
		cmp byte[bufferExpresion + r9 + 1], 7Ah
		jb .ponerAsterisco
		jmp .siguiente

	.terminar:
		mov al, byte[bufferExpresion + r9]
		mov byte[bufferExpTemp + r10], al
		inc r9
		inc r10
		mov al, byte[bufferExpresion + r9]
		mov byte[bufferExpTemp + r10], al

	.salir:
		call copiarBuffer
		call limpiarBuffer
		ret

quitarEspacios:

	xor r8, r8			; contador de caracteres para bufferExpresion
	xor r9, r9			; contador de caracteres para bufferExpTemp
	xor r10, r10
	mov r10, r15		; guarda el largo original para comparar y detenerse después
						; r15 (tamaño de EA) puede disminuir

	.recorrerExpresion:
		cmp byte[bufferExpresion + r8], ' '
		je .ignorarEspacio						; Si se encuentra un espacio, no lo copia
		mov al, byte[bufferExpresion + r8]
		mov byte[bufferExpTemp + r9], al 		; Copia en el buffer temporal
		inc r9									; Incrementa índice
		inc r8									; Incrementa índice
		cmp r8, r10								; Condición de parada: Terminó con caracteres
		jne .recorrerExpresion
		jmp .salir

	.ignorarEspacio:
		dec r15					 ; Por cada espacio que no copia, disminuye el largo de EA
		inc r8					 ; Sólo aumenta el contador de bufferExpresion
		cmp r8, r10				 ; Condición de parada de nuevo
		je .salir
		jmp .recorrerExpresion

	.salir:
		call copiarBuffer		 ; Copia al bufferExpresion lo que tiene en el temporal
		ret 					 ; La EA termina sin espacios intermedios

agregarParentesis:

	xor r8, r8 			; Para navegar en la expresión algebraica
	xor r9, r9			; Para navegar en el buffer temporal
	xor r10, r10		; Para buscar números que envuelven al '*' o '/'
	xor r12, r12
	xor r13, r13		; Para guardar la posición en la que dejó de copiar
	xor r14, r14		; Para los casos de paréntesis, contador
	xor rax, rax

	mov r12, r15		; copiamos el valor actual del tamaño del bufferExpresion
	;inc r12				; pues el r15 se va a modificar, incrementa r12 por condición de parada

	.buscarOperacion:

		cmp byte[bufferExpresion + r8], '*'		; Para multiplicaciones
		je .identificarCaso
		cmp byte[bufferExpresion + r8], '/'		; Para divisiones
		je .identificarCaso
		;mov al, byte[bufferExpresion + r8]		
		;mov byte[bufferExpTemp + r9], al 		; Copia a el buffer temporal
		inc r8
		cmp r8, r12
		je .cicloDeCopiadoFinal
		jmp .buscarOperacion

	.identificarCaso:

		cmp byte[bufferExpresion + r8 - 1], ')'
		je .divisionDeCasos
		cmp byte[bufferExpresion + r8 + 1], '('
		je .caso3
		jmp .caso1; Si llega aquí, los dos lados son números

	.divisionDeCasos:

		cmp byte[bufferExpresion + r8 + 1], '('
		je .caso4
		jmp .caso2

	.caso1: ; #*# o #/#

		mov r10, r8
		dec r10

	.parentesisAtrasCaso1:

		cmp r10, 0			; Excepción: Primera vez
		je .primeraVez

		cmp byte[bufferExpresion + r10], 30h
		jb .ponerParentesisAtras
		cmp byte[bufferExpresion + r10], 39h
		ja .ponerParentesisAtras

		dec r10
		jmp .parentesisAtrasCaso1

	.parentesisAdelante:
		inc r10

	.cicloParentesisAdelante: ; ADVERTENCIA: Se puede enciclar
		cmp byte[bufferExpresion + r10], 30h
		jb .ponerParentesisAdelante
		cmp byte[bufferExpresion + r10], 39h
		ja .ponerParentesisAdelante
		mov al, byte[bufferExpresion + r10]
		mov byte[bufferExpTemp + r9], al
		inc r9
		inc r10
		jmp .cicloParentesisAdelante

	.caso2:	; ()*# o ()/#

		mov r10, r8
		sub r10, 2
		mov r14, 1

	.cicloBuscadorDeParentesis:; AQUI HACE UN PUSH !!!! D:

		cmp byte[bufferExpresion + r10], ')'
		je .aumentarContadorParentesis 
		cmp byte[bufferExpresion + r10], '('
		je .bajarContadorParentesis
		dec r10
		cmp r14, 0
		jne .cicloBuscadorDeParentesis
		inc r10
		push r10
		dec r10
		;TERMINÓ Y LLEGÓ AL FINAL

	.aumentarContadorParentesis:
		inc r14
		dec r10
		cmp r14, 0
		jne .cicloBuscadorDeParentesis
		inc r10
		push r10
		dec r10
		;TERMINÓ Y LLEGÓ AL FINAL

	.bajarContadorParentesis:
		dec r14
		dec r10
		cmp r14, 0
		jne .cicloBuscadorDeParentesis
		inc r10
		;push r10
		dec r10
		;TERMINÓ Y LLEGÓ AL FINAL

	.ponerParentesisAtras:
		mov byte[bufferExpTemp + r9], '('
		inc r9
		jmp .cicloDeCopiadoHastaSimbolo

	.caso3:	; #*() o #/()	; Este también debe tener primera vez
		jmp exit


	.caso4:	; ()*() o #/()
		jmp exit

	.cicloDeCopiadoFaltante:

		mov al, byte[bufferExpresion + r13]
		mov byte[bufferExpTemp + r9], al
		inc r9
		inc r13
		cmp r13, r10
		ja .colocarParentesis
		jmp .cicloDeCopiadoFaltante

	.colocarParentesis:

		mov byte[bufferExpTemp + r9], '('
		inc r9
		inc r10

	.cicloDeCopiadoHastaSimbolo:

		mov al, byte[bufferExpresion + r10]
		mov byte[bufferExpTemp + r9], al
		inc r9
		inc r10
		cmp r10, r8
		ja .cicloParentesisAdelante
		jmp .cicloDeCopiadoHastaSimbolo


	.ponerParentesisAdelante:

		mov byte[bufferExpTemp + r9], ')'
		inc r9
		;xor r9, r9
		inc r8					; para que siga buscando la próxima operación
								; desde donde se quedó
		mov r13, r10			; para saber desde dónde copiar después
		;mov r8, r10

	.cicloDeCopiadoATemporal:

		cmp r13, r12
		je .preparacionParaCiclo

		mov al, byte[bufferExpresion + r13]
		mov byte[bufferExpTemp + r9], al
		inc r9
		inc r13
		cmp r13, r12
		jne .cicloDeCopiadoATemporal

	.preparacionParaCiclo:

		mov r12, r9			; nuevo tamaño de bufferExpresion
		xor r9, r9

		push rdx
		push rax
		push rsi
		push rdi

		mov rsi, bufferExpTemp
		mov rdx, buffExpTempLen
		call imprimir

		pop rdi
		pop rsi 
		pop rax 
		pop rdx

		pop r9
	
	.acabar:

		jmp .buscarOperacion


	.primeraVez: ;Excepción de ponerParentesisAtras

		mov byte[bufferExpTemp + r9], '('
		inc r9

	.cicloPrimeraVez:

		mov al, byte[bufferExpresion + r10]
		mov byte[bufferExpTemp + r9], al
		inc r9
		cmp byte[bufferExpresion + r10], '*'
		je .parentesisAdelante
		cmp byte[bufferExpresion + r10], '/'
		je .parentesisAdelante
		inc r10
		jmp .cicloPrimeraVez

	.cicloDeCopiadoFinal:

		mov al, byte[bufferExpresion + r13]
		mov byte[bufferExpTemp + r9], al
		inc r9
		inc r13
		cmp r13, r12
		jne .cicloDeCopiadoFinal

	.salir:
		push rdx
		push rax
		push rsi
		push rdi

		mov rsi, bufferExpTemp
		mov rdx, buffExpTempLen
		call imprimir

		pop rdi
		pop rsi 
		pop rax 
		pop rdx
		ret


comenzar:

	mov rsi, instruccion1
	mov rdx, lenInstruccion1
	call imprimir

	mov rsi, instruccion2
	mov rdx, lenInstruccion2
	call imprimir

	ret


exit:

	mov rax, 60
	mov rdi, 0
	syscall

